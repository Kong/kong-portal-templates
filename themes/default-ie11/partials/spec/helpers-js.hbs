{{!-- imports --}}
{{> common-helpers-js }}

<script text="text/javascript">
"use strict";

if (!window.helpers) {
  window.helpers = {};
}

window.helpers.buildSidebar = function (parsedSpec) {
  // If specFile contains array of errors return early
  if (window.helpers.isObject(parsedSpec) === false || !parsedSpec.paths) return; // Build object of sidebar data from the parsedSpec

  var acc = {}; // Set up accumulator object

  Object.keys(parsedSpec.paths).forEach(function (path) {
    var operationPath = parsedSpec.paths[path];
    Object.keys(operationPath).forEach(function (method) {
      // If the parsedSpec does not have any tags group everything under default
      var tags = operationPath[method].tags ? operationPath[method].tags : ['default'];
      tags.forEach(function (tag) {
        var operationTag = acc[tag] = acc[tag] || {};
        var operationMethod = operationTag[path] = operationTag[path] || {};
        var operationDetails = operationMethod[method] = operationMethod[method] || {};
        operationDetails.id = operationPath[method].operationId || Object.getOwnPropertyNames(operationMethod)[0] + '_' + buildSidebarURL(Object.getOwnPropertyNames(operationTag).slice(-1)[0]);
        operationDetails.summary = operationPath[method].summary || operationPath[method].description || 'summary undefined';
      });
    });
  }); // Transform acc object to an array and sort items to match rendered spec

  var sidebarArray = Object.keys(acc).map(function (tag) {
    return {
      tag: tag,
      paths: Object.keys(acc[tag]).map(function (path) {
        return {
          path: path,
          methods: Object.keys(acc[tag][path]).map(function (method) {
            return {
              method: method,
              id: acc[tag][path][method].id,
              summary: acc[tag][path][method].summary
            };
          })
        };
      })
    };
  }).sort(function (a, b) {
    return window.helpers.sortAlphabetical(a.tag, b.tag);
  });
  return sidebarArray;
};
/*
 * Lookup spec file to render from data attribute on page
 */


window.helpers.retrieveParsedSpec = function (name, spec) {
  if (!spec) {
    throw new Error("<p>Oops! Looks like we had trouble finding the spec: '".concat(name, "'</p>"));
  }

  var contents = spec.contents;
  var parsedSpec = parseSpec(contents); // If parseSpec returns array of errors then map them to DOM

  if (window.helpers.isObject(parsedSpec) === false) {
    throw new Error("<p>Oops! Something went wrong while parsing the spec: '".concat(name, "'</p>"));
  }

  return parsedSpec;
};

window.helpers.addEvent = function (parent, evt, selector, handler) {
  parent.addEventListener(evt, function (event) {
    if (event.target.matches(selector + ', ' + selector + ' *')) {
      handler.apply(event.target.closest(selector), arguments);
    }
  }, false);
}; // Check if spec is json or yaml


function parseSpec(contents) {
  var parsedSpec; // Set empty varible to hold spec

  var errorArray = []; // Set empty array to hold any errors
  // Try to parse spec as JSON
  // If parse fails push json error message into errors array

  try {
    parsedSpec = JSON.parse(contents);
  } catch (jsonError) {
    errorArray.push('Error trying to parse JSON:<br>' + jsonError); // Try to parse spec as YAML
    // If parse fails push yaml error message into errors array

    try {
      parsedSpec = YAML.load(contents);
    } catch (yamlError) {
      errorArray.push('Error trying to parse YAML:<br>' + yamlError);
    }
  } // If parsed is undefined return errors, else return the parsed spec file


  return parsedSpec;
} // Takes string (id) and replaces all instances of / , {} and -
// Characters to properly build URL for sidebar


function buildSidebarURL(string) {
  return string.replace(/\//, '').replace(/({|})/g, '_').replace(/\//g, '_').replace(/-/, '_');
}

</script>
